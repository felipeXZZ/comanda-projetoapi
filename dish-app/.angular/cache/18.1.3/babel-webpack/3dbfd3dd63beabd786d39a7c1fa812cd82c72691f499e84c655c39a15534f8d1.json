{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let PedidoService = /*#__PURE__*/(() => {\n  class PedidoService {\n    http;\n    apiUrl = 'http://localhost:8080/api/pedidos';\n    pedidosState = new BehaviorSubject([]);\n    //Um Observable público que os componentes podem ouvir\n    pedidos$ = this.pedidosState.asObservable();\n    constructor(http) {\n      this.http = http;\n    }\n    /**\n     * Busca todos os pedidos da API e \"avisa\"\n     * a todos os ouvintes (o BehaviorSubject)\n     */\n    loadAllPedidos() {\n      this.http.get(this.apiUrl).pipe(tap(data => this.pedidosState.next(data))).subscribe({\n        error: err => console.error('Erro ao carregar pedidos:', err)\n      });\n    }\n    /**\n     * Cria um novo pedido E ATUALIZA A LISTA\n     */\n    createPedido(pedidoData) {\n      return this.http.post(this.apiUrl, pedidoData).pipe(tap(() => {\n        this.loadAllPedidos();\n      }));\n    }\n    /**\n     * Busca um pedido\n     */\n    getPedidoById(id) {\n      return this.http.get(`${this.apiUrl}/${id}`);\n    }\n    /**\n     * Busca todos os pedidos\n     */\n    getAllPedidos() {\n      return this.http.get(this.apiUrl);\n    }\n    /**\n     * Atualiza o status E ATUALIZA A LISTA\n     * Atualiza o pedido localmente primeiro para evitar que ele desapareça temporariamente\n     * O backend espera { \"novoStatus\": \"EM_PREPARO\" } no body\n     */\n    updatePedidoStatus(id, novoStatus) {\n      const body = {\n        novoStatus: novoStatus\n      }; // Backend espera \"novoStatus\", não \"status\"\n      console.log(`Atualizando pedido ${id} para status: ${novoStatus}`, body);\n      return this.http.patch(`${this.apiUrl}/${id}/status`, body).pipe(tap({\n        next: pedidoAtualizado => {\n          console.log('Pedido atualizado com sucesso:', pedidoAtualizado);\n          // Atualiza o pedido localmente primeiro para evitar desaparecimento temporário\n          const pedidosAtuais = this.pedidosState.value;\n          const pedidosAtualizados = pedidosAtuais.map(pedido => pedido.id === pedidoAtualizado.id ? pedidoAtualizado : pedido);\n          this.pedidosState.next(pedidosAtualizados);\n          // Depois recarrega a lista completa do servidor para garantir sincronização\n          this.loadAllPedidos();\n        },\n        error: err => {\n          console.error('Erro ao atualizar status no serviço:', err);\n        }\n      }));\n    }\n    static ɵfac = function PedidoService_Factory(ɵt) {\n      return new (ɵt || PedidoService)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: PedidoService,\n      factory: PedidoService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PedidoService;\n})();","map":{"version":3,"names":["BehaviorSubject","tap","PedidoService","http","apiUrl","pedidosState","pedidos$","asObservable","constructor","loadAllPedidos","get","pipe","data","next","subscribe","error","err","console","createPedido","pedidoData","post","getPedidoById","id","getAllPedidos","updatePedidoStatus","novoStatus","body","log","patch","pedidoAtualizado","pedidosAtuais","value","pedidosAtualizados","map","pedido","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["D:\\ComandaProjeto\\ComandaProjeto\\dish-app\\dish-app\\src\\app\\services\\pedido.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable, BehaviorSubject } from 'rxjs'; \r\nimport { tap } from 'rxjs/operators';\r\n\r\n\r\n\r\nexport interface ItemPedido {\r\n\r\n  dish: { id: number };\r\n  quantidade: number;\r\n}\r\n\r\nexport interface Pedido {\r\n  // Dados do cliente\r\n  nomeCliente: string;\r\n  telefoneCliente: string;\r\n  enderecoCliente: string;\r\n  dataHora: string; // ou Date\r\n\r\n  // Lista de itens\r\n  itens: ItemPedido[];\r\n}\r\n\r\n// --- Interfaces para RECEBER dados do backend ---\r\nexport interface Dish {\r\n  id: number;\r\n  name: string;\r\n  price: number;\r\n}\r\n\r\nexport interface ItemPedidoCompleto {\r\n  id: number; \r\n  quantidade: number;\r\n  dish: Dish; \r\n}\r\n\r\nexport interface PedidoCompleto {\r\n  id: number;\r\n  nomeCliente: string;\r\n  telefoneCliente: string;\r\n  enderecoCliente: string;\r\n  dataHora: string; \r\n  status: string; \r\n  total: number;\r\n  itens: ItemPedidoCompleto[]; //\r\n  isLoading?: boolean;\r\n}\r\n\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class PedidoService {\r\n\r\n  private readonly apiUrl = 'http://localhost:8080/api/pedidos';\r\n\r\n  private pedidosState = new BehaviorSubject<PedidoCompleto[]>([]);\r\n  \r\n  //Um Observable público que os componentes podem ouvir\r\n  public pedidos$ = this.pedidosState.asObservable();\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * Busca todos os pedidos da API e \"avisa\"\r\n   * a todos os ouvintes (o BehaviorSubject)\r\n   */\r\n  public loadAllPedidos(): void {\r\n    this.http.get<PedidoCompleto[]>(this.apiUrl).pipe(\r\n      tap((data) => this.pedidosState.next(data))\r\n    ).subscribe({\r\n      error: (err) => console.error('Erro ao carregar pedidos:', err)\r\n    });\r\n  }\r\n  \r\n\r\n \r\n\r\n  /**\r\n   * Cria um novo pedido E ATUALIZA A LISTA\r\n   */\r\n  public createPedido(pedidoData: Pedido): Observable<PedidoCompleto> {\r\n    return this.http.post<PedidoCompleto>(this.apiUrl, pedidoData).pipe(\r\n      tap(() => {\r\n        this.loadAllPedidos(); \r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Busca um pedido \r\n   */\r\n  public getPedidoById(id: number): Observable<PedidoCompleto> {\r\n    return this.http.get<PedidoCompleto>(`${this.apiUrl}/${id}`);\r\n  }\r\n\r\n  /**\r\n   * Busca todos os pedidos \r\n   */\r\n  public getAllPedidos(): Observable<PedidoCompleto[]> {\r\n    return this.http.get<PedidoCompleto[]>(this.apiUrl);\r\n  }\r\n\r\n  /**\r\n   * Atualiza o status E ATUALIZA A LISTA\r\n   * Atualiza o pedido localmente primeiro para evitar que ele desapareça temporariamente\r\n   * O backend espera { \"novoStatus\": \"EM_PREPARO\" } no body\r\n   */\r\n  updatePedidoStatus(id: number, novoStatus: string): Observable<PedidoCompleto> {\r\n    const body = { novoStatus: novoStatus }; // Backend espera \"novoStatus\", não \"status\"\r\n    console.log(`Atualizando pedido ${id} para status: ${novoStatus}`, body);\r\n    \r\n    return this.http.patch<PedidoCompleto>(`${this.apiUrl}/${id}/status`, body).pipe(\r\n      tap({\r\n        next: (pedidoAtualizado) => {\r\n          console.log('Pedido atualizado com sucesso:', pedidoAtualizado);\r\n          // Atualiza o pedido localmente primeiro para evitar desaparecimento temporário\r\n          const pedidosAtuais = this.pedidosState.value;\r\n          const pedidosAtualizados = pedidosAtuais.map(pedido => \r\n            pedido.id === pedidoAtualizado.id ? pedidoAtualizado : pedido\r\n          );\r\n          this.pedidosState.next(pedidosAtualizados);\r\n          \r\n          // Depois recarrega a lista completa do servidor para garantir sincronização\r\n          this.loadAllPedidos(); \r\n        },\r\n        error: (err) => {\r\n          console.error('Erro ao atualizar status no serviço:', err);\r\n        }\r\n      })\r\n    );\r\n  }\r\n}"],"mappings":"AAEA,SAAqBA,eAAe,QAAQ,MAAM;AAClD,SAASC,GAAG,QAAQ,gBAAgB;;;AAkDpC,WAAaC,aAAa;EAApB,MAAOA,aAAa;IASJC,IAAA;IAPHC,MAAM,GAAG,mCAAmC;IAErDC,YAAY,GAAG,IAAIL,eAAe,CAAmB,EAAE,CAAC;IAEhE;IACOM,QAAQ,GAAG,IAAI,CAACD,YAAY,CAACE,YAAY,EAAE;IAElDC,YAAoBL,IAAgB;MAAhB,KAAAA,IAAI,GAAJA,IAAI;IAAgB;IAExC;;;;IAIOM,cAAcA,CAAA;MACnB,IAAI,CAACN,IAAI,CAACO,GAAG,CAAmB,IAAI,CAACN,MAAM,CAAC,CAACO,IAAI,CAC/CV,GAAG,CAAEW,IAAI,IAAK,IAAI,CAACP,YAAY,CAACQ,IAAI,CAACD,IAAI,CAAC,CAAC,CAC5C,CAACE,SAAS,CAAC;QACVC,KAAK,EAAGC,GAAG,IAAKC,OAAO,CAACF,KAAK,CAAC,2BAA2B,EAAEC,GAAG;OAC/D,CAAC;IACJ;IAKA;;;IAGOE,YAAYA,CAACC,UAAkB;MACpC,OAAO,IAAI,CAAChB,IAAI,CAACiB,IAAI,CAAiB,IAAI,CAAChB,MAAM,EAAEe,UAAU,CAAC,CAACR,IAAI,CACjEV,GAAG,CAAC,MAAK;QACP,IAAI,CAACQ,cAAc,EAAE;MACvB,CAAC,CAAC,CACH;IACH;IAEA;;;IAGOY,aAAaA,CAACC,EAAU;MAC7B,OAAO,IAAI,CAACnB,IAAI,CAACO,GAAG,CAAiB,GAAG,IAAI,CAACN,MAAM,IAAIkB,EAAE,EAAE,CAAC;IAC9D;IAEA;;;IAGOC,aAAaA,CAAA;MAClB,OAAO,IAAI,CAACpB,IAAI,CAACO,GAAG,CAAmB,IAAI,CAACN,MAAM,CAAC;IACrD;IAEA;;;;;IAKAoB,kBAAkBA,CAACF,EAAU,EAAEG,UAAkB;MAC/C,MAAMC,IAAI,GAAG;QAAED,UAAU,EAAEA;MAAU,CAAE,CAAC,CAAC;MACzCR,OAAO,CAACU,GAAG,CAAC,sBAAsBL,EAAE,iBAAiBG,UAAU,EAAE,EAAEC,IAAI,CAAC;MAExE,OAAO,IAAI,CAACvB,IAAI,CAACyB,KAAK,CAAiB,GAAG,IAAI,CAACxB,MAAM,IAAIkB,EAAE,SAAS,EAAEI,IAAI,CAAC,CAACf,IAAI,CAC9EV,GAAG,CAAC;QACFY,IAAI,EAAGgB,gBAAgB,IAAI;UACzBZ,OAAO,CAACU,GAAG,CAAC,gCAAgC,EAAEE,gBAAgB,CAAC;UAC/D;UACA,MAAMC,aAAa,GAAG,IAAI,CAACzB,YAAY,CAAC0B,KAAK;UAC7C,MAAMC,kBAAkB,GAAGF,aAAa,CAACG,GAAG,CAACC,MAAM,IACjDA,MAAM,CAACZ,EAAE,KAAKO,gBAAgB,CAACP,EAAE,GAAGO,gBAAgB,GAAGK,MAAM,CAC9D;UACD,IAAI,CAAC7B,YAAY,CAACQ,IAAI,CAACmB,kBAAkB,CAAC;UAE1C;UACA,IAAI,CAACvB,cAAc,EAAE;QACvB,CAAC;QACDM,KAAK,EAAGC,GAAG,IAAI;UACbC,OAAO,CAACF,KAAK,CAAC,sCAAsC,EAAEC,GAAG,CAAC;QAC5D;OACD,CAAC,CACH;IACH;;wBA/EWd,aAAa,EAAAiC,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,UAAA;IAAA;;aAAbpC,aAAa;MAAAqC,OAAA,EAAbrC,aAAa,CAAAsC,IAAA;MAAAC,UAAA,EAFZ;IAAM;;SAEPvC,aAAa;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}