{"ast":null,"code":"import { BehaviorSubject } from 'rxjs'; // 1. Importar BehaviorSubject\nimport { tap } from 'rxjs/operators'; // 2. Importar 'tap'\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let PedidoService = /*#__PURE__*/(() => {\n  class PedidoService {\n    http;\n    apiUrl = 'http://localhost:8080/api/pedidos';\n    // --- NOSSA FONTE ÚNICA DA VERDADE ---\n    // 3. Um \"sinalizador\" que guarda a lista de pedidos\n    pedidosState = new BehaviorSubject([]);\n    // 4. Um Observable público que os componentes podem \"ouvir\"\n    pedidos$ = this.pedidosState.asObservable();\n    constructor(http) {\n      this.http = http;\n    }\n    /**\n     * 5. Nova função: Busca todos os pedidos da API e \"avisa\"\n     * a todos os ouvintes (o BehaviorSubject)\n     */\n    loadAllPedidos() {\n      this.http.get(this.apiUrl).pipe(tap(data => this.pedidosState.next(data))).subscribe({\n        error: err => console.error('Erro ao carregar pedidos:', err)\n      });\n    }\n    // --- MÉTODOS QUE MUDAM O ESTADO ---\n    /**\n     * Cria um novo pedido E ATUALIZA A LISTA\n     */\n    createPedido(pedidoData) {\n      return this.http.post(this.apiUrl, pedidoData).pipe(tap(() => {\n        this.loadAllPedidos(); // 6. Após criar, recarrega a lista\n      }));\n    }\n    /**\n     * Busca um pedido (não mexe na lista principal, então fica igual)\n     */\n    getPedidoById(id) {\n      return this.http.get(`${this.apiUrl}/${id}`);\n    }\n    /**\n     * Busca todos os pedidos (NÃO USAR MAIS DIRETAMENTE, usar pedidos$)\n     */\n    getAllPedidos() {\n      return this.http.get(this.apiUrl);\n    }\n    /**\n     * Atualiza o status E ATUALIZA A LISTA\n     */\n    updatePedidoStatus(id, novoStatus) {\n      const body = {\n        status: novoStatus\n      };\n      return this.http.patch(`${this.apiUrl}/${id}/status`, body).pipe(tap(() => {\n        this.loadAllPedidos(); // 7. A MÁGICA: Após o patch, recarrega a lista\n      }));\n    }\n    static ɵfac = function PedidoService_Factory(ɵt) {\n      return new (ɵt || PedidoService)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: PedidoService,\n      factory: PedidoService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PedidoService;\n})();","map":{"version":3,"names":["BehaviorSubject","tap","PedidoService","http","apiUrl","pedidosState","pedidos$","asObservable","constructor","loadAllPedidos","get","pipe","data","next","subscribe","error","err","console","createPedido","pedidoData","post","getPedidoById","id","getAllPedidos","updatePedidoStatus","novoStatus","body","status","patch","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["D:\\ComandaProjeto\\ComandaProjeto\\dish-app\\dish-app\\src\\app\\services\\pedido.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable, BehaviorSubject } from 'rxjs'; // 1. Importar BehaviorSubject\r\nimport { tap } from 'rxjs/operators'; // 2. Importar 'tap'\r\n\r\n// --- Interfaces (Modelos de dados para Pedidos) ---\r\n// (Bloco completo que estava faltando)\r\n\r\nexport interface ItemPedido {\r\n  // Nota: enviamos apenas o ID do prato, o backend cuida do resto\r\n  dish: { id: number };\r\n  quantidade: number;\r\n}\r\n\r\nexport interface Pedido {\r\n  // Dados do cliente\r\n  nomeCliente: string;\r\n  telefoneCliente: string;\r\n  enderecoCliente: string;\r\n  dataCriacao: string; // ou Date\r\n\r\n  // Lista de itens\r\n  itens: ItemPedido[];\r\n}\r\n\r\n// --- Interfaces para RECEBER dados do backend ---\r\nexport interface Dish {\r\n  id: number;\r\n  name: string;\r\n  price: number;\r\n}\r\n\r\nexport interface ItemPedidoCompleto {\r\n  id: number; // ID do próprio item\r\n  quantidade: number;\r\n  dish: Dish; // O objeto Prato completo\r\n}\r\n\r\nexport interface PedidoCompleto {\r\n  id: number;\r\n  nomeCliente: string;\r\n  telefoneCliente: string;\r\n  enderecoCliente: string;\r\n  dataCriacao: string; // ou Date\r\n  status: string; // \"RECEBIDO\", \"EM_PREPARO\", etc.\r\n  total: number;\r\n  itens: ItemPedidoCompleto[]; // <-- Esta é a linha que deu erro\r\n  isLoading?: boolean;\r\n}\r\n\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class PedidoService {\r\n\r\n  private readonly apiUrl = 'http://localhost:8080/api/pedidos';\r\n\r\n  // --- NOSSA FONTE ÚNICA DA VERDADE ---\r\n  // 3. Um \"sinalizador\" que guarda a lista de pedidos\r\n  private pedidosState = new BehaviorSubject<PedidoCompleto[]>([]);\r\n  \r\n  // 4. Um Observable público que os componentes podem \"ouvir\"\r\n  public pedidos$ = this.pedidosState.asObservable();\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * 5. Nova função: Busca todos os pedidos da API e \"avisa\"\r\n   * a todos os ouvintes (o BehaviorSubject)\r\n   */\r\n  public loadAllPedidos(): void {\r\n    this.http.get<PedidoCompleto[]>(this.apiUrl).pipe(\r\n      tap((data) => this.pedidosState.next(data))\r\n    ).subscribe({\r\n      error: (err) => console.error('Erro ao carregar pedidos:', err)\r\n    });\r\n  }\r\n  \r\n\r\n  // --- MÉTODOS QUE MUDAM O ESTADO ---\r\n\r\n  /**\r\n   * Cria um novo pedido E ATUALIZA A LISTA\r\n   */\r\n  public createPedido(pedidoData: Pedido): Observable<PedidoCompleto> {\r\n    return this.http.post<PedidoCompleto>(this.apiUrl, pedidoData).pipe(\r\n      tap(() => {\r\n        this.loadAllPedidos(); // 6. Após criar, recarrega a lista\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Busca um pedido (não mexe na lista principal, então fica igual)\r\n   */\r\n  public getPedidoById(id: number): Observable<PedidoCompleto> {\r\n    return this.http.get<PedidoCompleto>(`${this.apiUrl}/${id}`);\r\n  }\r\n\r\n  /**\r\n   * Busca todos os pedidos (NÃO USAR MAIS DIRETAMENTE, usar pedidos$)\r\n   */\r\n  public getAllPedidos(): Observable<PedidoCompleto[]> {\r\n    return this.http.get<PedidoCompleto[]>(this.apiUrl);\r\n  }\r\n\r\n  /**\r\n   * Atualiza o status E ATUALIZA A LISTA\r\n   */\r\n  updatePedidoStatus(id: number, novoStatus: string): Observable<PedidoCompleto> {\r\n    const body = { status: novoStatus }; \r\n    return this.http.patch<PedidoCompleto>(`${this.apiUrl}/${id}/status`, body).pipe(\r\n      tap(() => {\r\n        this.loadAllPedidos(); // 7. A MÁGICA: Após o patch, recarrega a lista\r\n      })\r\n    );\r\n  }\r\n}"],"mappings":"AAEA,SAAqBA,eAAe,QAAQ,MAAM,CAAC,CAAC;AACpD,SAASC,GAAG,QAAQ,gBAAgB,CAAC,CAAC;;;AAmDtC,WAAaC,aAAa;EAApB,MAAOA,aAAa;IAWJC,IAAA;IATHC,MAAM,GAAG,mCAAmC;IAE7D;IACA;IACQC,YAAY,GAAG,IAAIL,eAAe,CAAmB,EAAE,CAAC;IAEhE;IACOM,QAAQ,GAAG,IAAI,CAACD,YAAY,CAACE,YAAY,EAAE;IAElDC,YAAoBL,IAAgB;MAAhB,KAAAA,IAAI,GAAJA,IAAI;IAAgB;IAExC;;;;IAIOM,cAAcA,CAAA;MACnB,IAAI,CAACN,IAAI,CAACO,GAAG,CAAmB,IAAI,CAACN,MAAM,CAAC,CAACO,IAAI,CAC/CV,GAAG,CAAEW,IAAI,IAAK,IAAI,CAACP,YAAY,CAACQ,IAAI,CAACD,IAAI,CAAC,CAAC,CAC5C,CAACE,SAAS,CAAC;QACVC,KAAK,EAAGC,GAAG,IAAKC,OAAO,CAACF,KAAK,CAAC,2BAA2B,EAAEC,GAAG;OAC/D,CAAC;IACJ;IAGA;IAEA;;;IAGOE,YAAYA,CAACC,UAAkB;MACpC,OAAO,IAAI,CAAChB,IAAI,CAACiB,IAAI,CAAiB,IAAI,CAAChB,MAAM,EAAEe,UAAU,CAAC,CAACR,IAAI,CACjEV,GAAG,CAAC,MAAK;QACP,IAAI,CAACQ,cAAc,EAAE,CAAC,CAAC;MACzB,CAAC,CAAC,CACH;IACH;IAEA;;;IAGOY,aAAaA,CAACC,EAAU;MAC7B,OAAO,IAAI,CAACnB,IAAI,CAACO,GAAG,CAAiB,GAAG,IAAI,CAACN,MAAM,IAAIkB,EAAE,EAAE,CAAC;IAC9D;IAEA;;;IAGOC,aAAaA,CAAA;MAClB,OAAO,IAAI,CAACpB,IAAI,CAACO,GAAG,CAAmB,IAAI,CAACN,MAAM,CAAC;IACrD;IAEA;;;IAGAoB,kBAAkBA,CAACF,EAAU,EAAEG,UAAkB;MAC/C,MAAMC,IAAI,GAAG;QAAEC,MAAM,EAAEF;MAAU,CAAE;MACnC,OAAO,IAAI,CAACtB,IAAI,CAACyB,KAAK,CAAiB,GAAG,IAAI,CAACxB,MAAM,IAAIkB,EAAE,SAAS,EAAEI,IAAI,CAAC,CAACf,IAAI,CAC9EV,GAAG,CAAC,MAAK;QACP,IAAI,CAACQ,cAAc,EAAE,CAAC,CAAC;MACzB,CAAC,CAAC,CACH;IACH;;wBA/DWP,aAAa,EAAA2B,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,UAAA;IAAA;;aAAb9B,aAAa;MAAA+B,OAAA,EAAb/B,aAAa,CAAAgC,IAAA;MAAAC,UAAA,EAFZ;IAAM;;SAEPjC,aAAa;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}