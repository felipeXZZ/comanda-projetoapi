{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let PedidoService = /*#__PURE__*/(() => {\n  class PedidoService {\n    http;\n    // A URL base da API de Pedidos (que criamos no Java)\n    apiUrl = 'http://localhost:8080/api/pedidos';\n    constructor(http) {\n      this.http = http;\n    }\n    // --- MÉTODOS PARA PEDIDO ---\n    /**\n     * Cria um novo pedido\n     * Chama: POST /api/pedidos\n     */\n    createPedido(pedidoData) {\n      return this.http.post(this.apiUrl, pedidoData);\n    }\n    /**\n     * Busca um pedido específico pelo ID (para rastreamento)\n     * Chama: GET /api/pedidos/{id}\n     */\n    getPedidoById(id) {\n      return this.http.get(`${this.apiUrl}/${id}`);\n    }\n    /**\n     * Busca todos os pedidos\n     * Chama: GET /api/pedidos\n     */\n    getAllPedidos() {\n      return this.http.get(this.apiUrl);\n    }\n    /**\n     * Atualiza o status de um pedido\n     * Chama: PATCH /api/pedidos/{id}/status\n     */\n    updatePedidoStatus(id, novoStatus) {\n      // O corpo da requisição.\n      const body = {\n        status: novoStatus\n      };\n      // Usamos PATCH para atualizar parcialmente, que é o ideal para status.\n      return this.http.patch(`${this.apiUrl}/${id}`, body);\n      /* * NOTA: Se seu backend NÃO aceita PATCH e espera um PUT com o objeto inteiro,\n       * você terá que fazer um getPedidoById, alterar o status, e mandar o objeto\n       * inteiro com PUT. Mas o PATCH acima é o mais comum.\n       */\n    }\n    static ɵfac = function PedidoService_Factory(ɵt) {\n      return new (ɵt || PedidoService)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: PedidoService,\n      factory: PedidoService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PedidoService;\n})();","map":{"version":3,"names":["PedidoService","http","apiUrl","constructor","createPedido","pedidoData","post","getPedidoById","id","get","getAllPedidos","updatePedidoStatus","novoStatus","body","status","patch","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["C:\\Users\\jvgam\\OneDrive\\Área de Trabalho\\ComandaProjeto\\dish-app\\dish-app\\src\\app\\services\\pedido.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\n\r\n// --- Interfaces (Modelos de dados para Pedidos) ---\r\n\r\nexport interface ItemPedido {\r\n  // Nota: enviamos apenas o ID do prato, o backend cuida do resto\r\n  dish: { id: number };\r\n  quantidade: number;\r\n}\r\n\r\nexport interface Pedido {\r\n  // Dados do cliente\r\n  nomeCliente: string;\r\n  telefoneCliente: string;\r\n  enderecoCliente: string;\r\n\r\n  // Lista de itens\r\n  itens: ItemPedido[];\r\n}\r\n\r\nexport interface PedidoCompleto {\r\n  id: number;\r\n  nomeCliente: string;\r\n  telefoneCliente: string;\r\n  enderecoCliente: string;\r\n  dataCriacao: string; // ou Date\r\n  status: string; // \"RECEBIDO\", \"EM_PREPARO\", etc.\r\n  total: number;\r\n  itens: any[]; // Pode ser mais detalhado se quisermos\r\n}\r\n\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class PedidoService {\r\n\r\n  // A URL base da API de Pedidos (que criamos no Java)\r\n  private readonly apiUrl = 'http://localhost:8080/api/pedidos';\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  // --- MÉTODOS PARA PEDIDO ---\r\n\r\n  /**\r\n   * Cria um novo pedido\r\n   * Chama: POST /api/pedidos\r\n   */\r\n  public createPedido(pedidoData: Pedido): Observable<PedidoCompleto> {\r\n    return this.http.post<PedidoCompleto>(this.apiUrl, pedidoData);\r\n  }\r\n\r\n  /**\r\n   * Busca um pedido específico pelo ID (para rastreamento)\r\n   * Chama: GET /api/pedidos/{id}\r\n   */\r\n  public getPedidoById(id: number): Observable<PedidoCompleto> {\r\n    return this.http.get<PedidoCompleto>(`${this.apiUrl}/${id}`);\r\n  }\r\n\r\n  /**\r\n   * Busca todos os pedidos\r\n   * Chama: GET /api/pedidos\r\n   */\r\n  public getAllPedidos(): Observable<PedidoCompleto[]> {\r\n    return this.http.get<PedidoCompleto[]>(this.apiUrl);\r\n  }\r\n\r\n  /**\r\n   * Atualiza o status de um pedido\r\n   * Chama: PATCH /api/pedidos/{id}/status\r\n   */\r\n  updatePedidoStatus(id: number, novoStatus: string): Observable<PedidoCompleto> {\r\n    // O corpo da requisição.\r\n    const body = { status: novoStatus }; \r\n    \r\n    // Usamos PATCH para atualizar parcialmente, que é o ideal para status.\r\n    return this.http.patch<PedidoCompleto>(`${this.apiUrl}/${id}`, body);\r\n    \r\n    /* * NOTA: Se seu backend NÃO aceita PATCH e espera um PUT com o objeto inteiro, \r\n     * você terá que fazer um getPedidoById, alterar o status, e mandar o objeto \r\n     * inteiro com PUT. Mas o PATCH acima é o mais comum.\r\n     */\r\n  }\r\n}\r\n"],"mappings":";;AAqCA,WAAaA,aAAa;EAApB,MAAOA,aAAa;IAKJC,IAAA;IAHpB;IACiBC,MAAM,GAAG,mCAAmC;IAE7DC,YAAoBF,IAAgB;MAAhB,KAAAA,IAAI,GAAJA,IAAI;IAAgB;IAExC;IAEA;;;;IAIOG,YAAYA,CAACC,UAAkB;MACpC,OAAO,IAAI,CAACJ,IAAI,CAACK,IAAI,CAAiB,IAAI,CAACJ,MAAM,EAAEG,UAAU,CAAC;IAChE;IAEA;;;;IAIOE,aAAaA,CAACC,EAAU;MAC7B,OAAO,IAAI,CAACP,IAAI,CAACQ,GAAG,CAAiB,GAAG,IAAI,CAACP,MAAM,IAAIM,EAAE,EAAE,CAAC;IAC9D;IAEA;;;;IAIOE,aAAaA,CAAA;MAClB,OAAO,IAAI,CAACT,IAAI,CAACQ,GAAG,CAAmB,IAAI,CAACP,MAAM,CAAC;IACrD;IAEA;;;;IAIAS,kBAAkBA,CAACH,EAAU,EAAEI,UAAkB;MAC/C;MACA,MAAMC,IAAI,GAAG;QAAEC,MAAM,EAAEF;MAAU,CAAE;MAEnC;MACA,OAAO,IAAI,CAACX,IAAI,CAACc,KAAK,CAAiB,GAAG,IAAI,CAACb,MAAM,IAAIM,EAAE,EAAE,EAAEK,IAAI,CAAC;MAEpE;;;;IAIF;;wBAhDWb,aAAa,EAAAgB,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,UAAA;IAAA;;aAAbnB,aAAa;MAAAoB,OAAA,EAAbpB,aAAa,CAAAqB,IAAA;MAAAC,UAAA,EAFZ;IAAM;;SAEPtB,aAAa;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}